#
# Software Name: Orange Unified Design System
# SPDX-FileCopyrightText: Copyright (c) Orange SA
# SPDX-License-Identifier: MIT
#
# This software is distributed under the MIT license,
# the text of which is available at https://opensource.org/license/MIT/
# or see the "LICENSE" file for more details.
#
# Authors: See CONTRIBUTORS.txt
# Software description: A SwiftUI components library with code examples for Orange Unified Design System
#

# App features configuration
# --------------------------

# TODO Add URL for MoreApps module to get feed from APPS_PLUS backend (cf github.com/Orange-OpenSource/ods-ios)

# Apple configuration
# -------------------

# TestFlight
# Configuration for App Store Connect API (https://appstoreconnect.apple.com/access/integrations/api)
#   OUDS_APPLE_ISSUER_ID = Issuer identifier (unique to group)
#   OUDS_APPLE_KEY_ID = key identifier (for the app)
#   OUDS_APPLE_KEY_CONTENT = private key associated to the key identifier
APPLE_ISSUER_ID = ENV["OUDS_APPLE_ISSUER_ID"]
APPLE_KEY_ID = ENV["OUDS_APPLE_KEY_ID"]
APPLE_KEY_CONTENT = ENV["OUDS_APPLE_KEY_CONTENT"]

# Bundle identifier of the app
DEVELOPER_APP_IDENTIFIER = ENV["OUDS_DEVELOPER_BUNDLE_IDENTIFIER"]

# Notifications and hooks
# -----------------------

MATTERMOST_HOOK_URL = ENV["OUDS_MATTERMOST_HOOK_URL"]
MATTERMOST_HOOK_BOT_NAME = ENV["OUDS_MATTERMOST_HOOK_BOT_NAME"]
MATTERMOST_HOOK_BOT_ICON_URL = ENV["OUDS_MATTERMOST_HOOK_BOT_ICON_URL"]

# GitHub
# ------

# Fine grained personal access token with enough permissions for the suitable GitHub project
GITHUB_ACCESS_TOKEN = ENV['GITHUB_ACCESS_TOKEN']

# Should be last commit full hash, for builds and tags
IOS_APP_COMMIT_SHA = ENV['IOS_APP_COMMIT_SHA']

# Project configuration
# ---------------------

OUDS_WORKSPACE = "Showcase.xcworkspace"
OUDS_PROJECT = "Showcase.xcodeproj"
OUDS_SCHEME = "Showcase"

# Lanes
# ------

default_platform(:ios)

platform :ios do

    before_all do |lane, options|
        xcversion(version: "~> 15.3")
    end

    # ------------------------------------------------------------
    # UPDATE BUILD NUMBER WITH TIMESTAMP
    # ------------------------------------------------------------
    desc "UPDATE BUILD NUMBER WITH TIMESTAMP"
    lane :update_build_number do
        puts "üëâ Update build number"

        timestamp = sh 'date +%s' # Timestamp are unique and bring details about build date
        timestamp = timestamp.strip!
        puts "‚ÑπÔ∏è New builder number: '#{timestamp}'"

        increment_build_number(xcodeproj: OUDS_PROJECT, build_number: timestamp)
    end

    # TODO Add lane for add_credentials_appsplus (cf github.com/Orange-OpenSource/ods-ios)

    # ---------
    # RUN TESTS
    # ---------
    desc "RUN TESTS BY TRIGGERING THE TESTS PLANS OF THE PROJECT"
    lane :test do
        puts "üëâ Run tests"

        # Should have on runner one device under at least iOS 15
        # Check the available devices using `xcrun xctrace list devices`
        # Add new environments using `xcodebuild -downloadPlatform iOS`
        begin
            device = "iPhone 14"
            scan(scheme: "Showcase",
                device: device,
                skip_build: true)

            publish_mattermost_notification("üß™ ‚úÖ No issue with tests")

        rescue => error
            publish_mattermost_notification("üß™ üö® @channel Some issue occured with tests (:test)")
            raise error
        end
    end

    # ------------------------------------------------------------
    # READ AND SET NEXT RELEASE NOTE IN CHANGELOG
    # ------------------------------------------------------------
    # TODO Maybe this lane should be removed or updated if we have several changelogs or if we use git-cliff
    desc "READ AND SET NEXT RELEASE NOTE IN CHANGELOG"
    lane :prepare_release do
        puts "üëâ Prepare release"

        version = get_app_version

        stamp_changelog(
            changelog_path: '../CHANGELOG.md',
            section_identifier: version,
            git_tag: version,
            should_stamp_date: true,
            stamp_datetime_format: '%F'
        )
    end

    # ------------------------------------------------------------
    # BUILD DEBUG APP
    # ------------------------------------------------------------
    desc "BUILD DEBUG APP"
    lane :buildDebugApp do
        puts "üëâ Build debug app"

        cocoapods(
          clean_install: true
        )

        gym(
            scheme: OUDS_SCHEME,
            output_directory: 'build/',
            archive_path: 'build/',
            output_name: 'oudsApp',
            configuration: 'Debug',
            include_symbols: true,
            export_method: 'development'
        )
    end

    # ------------------------------------------------------------
    # BUILD & UPLOAD TO TESTFLIGHT ALPHA APP
    # ------------------------------------------------------------
    desc "BUILD & UPLOAD TO TESTFLIGHT ALPHA APP"
    lane :alpha do |params|
        puts "üëâ Alpha (commit hash = '#{params[:commitHash]}, issue number = '#{params[:issueNumber]}')"
        Dir.chdir "../Showcase/Resources/Assets.xcassets" do
            sh "rm -Rf AppIconRelease.appiconset"
            sh "cp -R AppIconDev.appiconset AppIconRelease.appiconset"
        end

        # CFBundleVersion and CFBundleShortVersionString must follow rules with integers and periods, should not change them
        # But still possible to change CFBundleDisplayName
        new_display_name = "OUDS Showcase ALPHA (#{params[:issueNumber]})"
        puts "‚ÑπÔ∏è New display name version will be: '#{new_display_name}'"
        set_info_plist_value(path: "#{Dir.pwd}/../Showcase/Info.plist", key: "CFBundleDisplayName", value: new_display_name)

        # Details for the GUI in the app
        set_info_plist_value(path: "#{Dir.pwd}/../Showcase/Info.plist", key: "OUDSBuildType", value: "ALPHA")
        set_info_plist_value(path: "#{Dir.pwd}/../Showcase/Info.plist", key: "OUDSBuildTag", value: "#{params[:commitHash][0,7]}".strip)
        set_info_plist_value(path: "#{Dir.pwd}/../Showcase/Info.plist", key: "OUDSBuildDetails", value: "#{params[:issueNumber]}")

        build_and_upload(isAlpha: true, upload: true)
    end

    # ------------------------------------------------------------
    # BUILD & UPLOAD TO TESTFLIGHT BETA APP
    # ------------------------------------------------------------
    desc "BUILD & UPLOAD TO TESTFLIGHT BETA APP"
    lane :beta do |params|
        puts "üëâ Beta (commit hash = '#{params[:commitHash]}')"
        Dir.chdir "../Showcase/Resources/Assets.xcassets" do
            sh "rm -Rf AppIconRelease.appiconset"
            sh "cp -R AppIconQualif.appiconset AppIconRelease.appiconset"
        end

        new_display_name = "OUDS Showcase (BETA)"
        puts "‚ÑπÔ∏è New display name version will be: '#{new_display_name}'"
        set_info_plist_value(path: "#{Dir.pwd}/../Showcase/Info.plist", key: "CFBundleDisplayName", value: new_display_name)

        # Details for the GUI in the app
        set_info_plist_value(path: "#{Dir.pwd}/../Showcase/Info.plist", key: "OUDSBuildType", value: "BETA")
        set_info_plist_value(path: "#{Dir.pwd}/../Showcase/Info.plist", key: "OUDSBuildTag", value: "#{params[:commitHash][0,7]}".strip)
        
        build_and_upload(isAlpha: false, upload: true, detailSymbol: params[:commitHash])
    end

    # ------------------------------------------------------------
    # BUILD & UPLOAD TO TESTFLIGHT PROD APP
    # ------------------------------------------------------------
    desc "BUILD & UPLOAD TO TESTFLIGHT (if set in options: upload) PROD APP"
    lane :prod do |params|
        puts "üëâ Prod"
        update_build_number

        new_display_name = "OUDS Showcase"
        puts "‚ÑπÔ∏è New display name version will be: '#{new_display_name}'"
        set_info_plist_value(path: "#{Dir.pwd}/../Showcase/Info.plist", key: "CFBundleDisplayName", value: new_display_name)

        # Details for the GUI in the app
        set_info_plist_value(path: "#{Dir.pwd}/../Showcase/Info.plist", key: "OUDSBuildType", value: "PROD")
        
        build
        if params[:upload]
            puts "Upload to TestFlight requested"
            upload
        else
            puts "Upload to TestFlight not requested"
        end
    end

    # -----------------------------------------------------------------------
    # PRIVATE LANE BUILD & UPLOAD (ALPHA / BETA / PROD is set by main lane)
    # -----------------------------------------------------------------------
    private_lane :build_and_upload do |params|
        isAlpha = params[:isAlpha]

        if isAlpha # Alpha case, detailSymbol should be the issue number of the feature/fix to test
            puts "üëâ Build and upload (alpha)"
            update_build_number
            build
            upload 

        else # Beta case (not production too), detailSymbol should be here commit hash
            detailSymbol = params[:detailSymbol]
            puts "üëâ Build and upload (alpha = #{isAlpha}), detail symbol = #{detailSymbol})"
            
            # If already built, prevents to build again for nothing
            # Warning: tag is done before build and not removed, so if build failed, tag will remain and needs to be removed manualy.
            # It prevents to have loops of failing builds.
            if tag_ci_build(detailSymbol)
                # Ensure this build-then-uploaded app has a new and unique build number matching also to code version
                update_build_number
                build
            else
                puts "Nothing new to build today, a CI tag for commit '#{detailSymbol}' already exists"
                publish_mattermost_notification("‚öôÔ∏è ü§î Nothing new to build today, a CI tag for commit '#{detailSymbol}' already exists")
            end
            
            if params[:upload]
                puts "Upload to TestFlight requested"
                # If already uploaded, prevents to upload again
                if tag_testflight_upload(detailSymbol)
                    upload 
                else
                    puts "Nothing new to build today, a TestFlight tag for commit '#{detailSymbol}' already exists"
                    publish_mattermost_notification("‚öôÔ∏è ü§î Nothing new to build today, a TestFlight tag for commit '#{detailSymbol}' already exists")
                end
            else
                puts "Upload to TestFlight not requested"
            end

        end
    end

    # -----------------------------------------------------------------------
    # PRIVATE LANE BUILD (ALPHA / BETA / PROD is set by main lane)
    # -----------------------------------------------------------------------
    desc "PRIVATE LANE BUILD (ALPHA / BETA / PROD is set by main lane)"
    private_lane :build do
        puts "üëâ Build"

        begin
            update_app_identifier(
                xcodeproj: "#{OUDS_PROJECT}",
                plist_path: "Showcase/Info.plist",
                app_identifier: CredentialsManager::AppfileConfig.try_fetch_value(:app_identifier)
            )

            cocoapods(
                clean_install: true
            )

            # Disable automatic code signing for release / distribution builds.
            # Thus we won't use any Xcode with plugged account in, and use only needed certificates and provisioning profiles.
            # Mobile provisioning profile named "OUDS demo app (release)" must be placed in runner.
            # The certificate(s) used to build (with bundle ID) the provisionning profile must be available in the keychain of the runner
            # (both .cer and .p12), here a distribution certificate.
            # This way is more agile and allows to use VM-based solution with on the fly configuration like with Tart.
            update_code_signing_settings(path: "#{OUDS_PROJECT}",
                use_automatic_signing: false,
                profile_name: 'OUDS demo app (release)',
                targets: OUDS_SCHEME)
            
            gym(workspace: "#{OUDS_WORKSPACE}",
                scheme: OUDS_SCHEME,
                configuration: "Release",
                output_directory: "build/",
                export_method: "app-store",
                archive_path: "build/oudsApp.xcarchive",
                xcargs: "-allowProvisioningUpdates")
            
            # Build a ZIP archive to put as artifact to the GitLab CI runner
            # Needed for upload later as .xcarchive for App Store through corporate portal
            zip(path: "build/oudsApp.xcarchive",
                output_path: "build/oudsApp.zip")

                          
            version = get_app_version
            build_number = get_build_number(xcodeproj: OUDS_PROJECT)

            publish_mattermost_notification("üî® ‚úÖ A new build has been done successfully (version = '#{version}', build number = '#{build_number}')")
        rescue => error
            publish_mattermost_notification("üî® üö® @channel Some issue occurred during the build step (:build)")
            raise error
        end
    end

    # --------------------------------------------------------------------------
    # PRIVATE LANE UPLOAD TO TESTFLIGHT (ALPHA / BETA / PROD is set by main lane)
    # ---------------------------------------------------------------------------
    desc "PRIVATE LANE UPLOAD TO TESTFLIGHT"
    private_lane :upload do
        puts "üëâ Upload"

        begin
            api_key = app_store_connect_api_key(
                key_id: APPLE_KEY_ID,
                issuer_id: APPLE_ISSUER_ID,
                key_content: APPLE_KEY_CONTENT,
                duration: 500,
                in_house: false
            )
            
            TESTFLIGHT_GROUPS = ENV['TESTFLIGHT_GROUPS'] # Defined in Appfile
            
            version = get_app_version
            puts "‚ÑπÔ∏è App version: '#{version}'"

            build_number = get_build_number(xcodeproj: OUDS_PROJECT)
            puts "‚ÑπÔ∏è App build number: '#{build_number}'"

            news = read_current_release_notes

            upload_to_testflight(
                changelog: news,
                app_identifier: "#{DEVELOPER_APP_IDENTIFIER}",
                skip_submission: false,
                skip_waiting_for_build_processing: false,
                distribute_external: true,
                notify_external_testers: true,
                groups: TESTFLIGHT_GROUPS,
                api_key: api_key
            )
            
            publish_mattermost_notification("üì¶ ‚úÖ @here The upload to TestFlight has been done successfully (version = '#{version}', build number = '#{build_number}')")    
        rescue => error
            publish_mattermost_notification("üì¶ üö® @channel Some issue occurred during the upload step (:upload)")
            raise error
        end
    end
    
    # -------
    # Helpers
    # -------

    # Add a Git tag dedicated to CI/CD builds with for some commit hash used to compute tag suffix
    def tag_ci_build(commitHash)
        puts "üëâ Tag CI build"

        begin
            if commitHash.nil? || commitHash.empty?
                puts "No parameter sent for CI tag, nothing will be done"
                publish_mattermost_notification("‚öôÔ∏è ü§î No commit hash has been given, no tag can be created")
                return false
            else
                expected_git_tag = "ci/" + commitHash[0,7]
                if create_tag(expected_git_tag)
                    publish_mattermost_notification("üì¶ ‚úÖ  New Git tag created: #{expected_git_tag}")
                    return true
                else
                    return false
                end
            end
        rescue => error
            publish_mattermost_notification("üì¶ üö® @channel Some issue occurred during the tagging step (:tag_ci_build)")
            raise error
        end
    end

    # Add a Git tag dedicated to TestFLight uploads for some commit hash used to compute tag suffix
    def tag_testflight_upload(commitHash)
        puts "üëâ Tag TestFlight upload"

        begin     
            if commitHash.nil? || commitHash.empty?
                puts "No parameter sent for CI tag, nothing will be done"
                publish_mattermost_notification("‚öôÔ∏è ü§î No commit hash has been given, no tag can be created")
                return false
            else
                expected_git_tag = "Test_Flight/" + commitHash[0,7]
                if create_tag(expected_git_tag)
                    publish_mattermost_notification("üì¶ ‚úÖ New Git tag created: #{expected_git_tag}")
                    return true
                else
                    return false
                end
            end
        rescue => error
            publish_mattermost_notification("üì¶ üö® @channel Some issue occurred during the tagging step (:tag_testflight_upload)")
            raise error
        end
    end

    # Creates a Git tag at given commit through HTTP protocol to prevent proxy or firewalls to block SSH requests.
    # Not possible also to make repository mirroring because of the current purchased plan of the GitLab instance.
    def create_tag(tag)
      
        # Check personal access token for tag creation
        if GITHUB_ACCESS_TOKEN.nil? || GITHUB_ACCESS_TOKEN.empty?
            puts "Error: No GitHub access token defined, cannot create and push tags"
            publish_mattermost_notification("‚öôÔ∏è üò∞ @channel No GitHub access token defined, cannot create and push tags!")
            return false
        else
            # Check if given tag exists yet
            puts "Check if '#{tag}' exists yet"
            result=sh("curl -s 'https://api.github.com/repos/Orange-OpenSource/ouds-ios/git/refs/tags/#{tag}' | jq -r '.ref'") # TODO Shell error management
            # If tag exists, CURL response is formatted like "refs/tags/tag"
            if "refs/tags/#{tag}".eql? result.strip # Removes line break available in command result
                puts "The tag '#{tag}' still exists, won't create new tag"
                return false
            else
                puts "Commit SHA to tag is '#{IOS_APP_COMMIT_SHA}'"
                # Just a light tag is enough 
                sh("curl -L \
                  -X POST \
                  -H 'Accept: application/vnd.github+json' \
                  -H 'Authorization: Bearer #{GITHUB_ACCESS_TOKEN}'\
                  -H 'X-GitHub-Api-Version: 2022-11-28' \
                  https://api.github.com/repos/Orange-OpenSource/ouds-ios/git/refs \
                  -d '{\"ref\":\"refs/tags/#{tag}\",\"sha\":\"#{IOS_APP_COMMIT_SHA}\"}'") # TODO Shell error management
                  return true
              end
        end
    end

    # Sends a message notification through Mattermost hook
    def publish_mattermost_notification(message)
        mattermost(url: MATTERMOST_HOOK_URL,
                  text: "#{message}",
                  username: MATTERMOST_HOOK_BOT_NAME,
                  icon_url: MATTERMOST_HOOK_BOT_ICON_URL
                  )
    end

    # Get version set in the Xcode project
    def get_app_version
        version = get_version_number(
            xcodeproj: OUDS_PROJECT,
            target: OUDS_SCHEME
        )
        return version
    end

    # Read release note in section associated to the current version
    # If empty, try within the Unreleased section
    def read_current_release_notes
        version = get_app_version

        changelog=read_changelog(
            changelog_path: '../CHANGELOG.md',
            section_identifier: "[#{version}]",
        )

        if changelog == ""
            changelog=read_changelog(
                changelog_path: '../CHANGELOG.md',
                section_identifier: "[Unreleased]",
            )
        end

        puts "Current relase notes = #{changelog}"
        return changelog
    end
end
