//
// Software Name: OUDS iOS
// SPDX-FileCopyrightText: Copyright (c) Orange SA
// SPDX-License-Identifier: MIT
//
// This software is distributed under the MIT license,
// the text of which is available at https://opensource.org/license/MIT/
// or see the "LICENSE" file for more details.
//
// Authors: See CONTRIBUTORS.txt
// Software description: A SwiftUI components library with code examples for Orange Unified Design System
//

import OUDSFoundations
import OUDSTokensRaw
import SwiftUI

// MARK: - Multiple Color Semantic Tokens

/// Kind of semantic tokens which will wrap a combination of ``ColorSemanticToken`` depending to *color scheme* (i.e. ligh mode or dark mode).
/// Kind of composite token with multiple values, but not named "composite" because this word is already used in the design system.
/// Allows to gather the multiple-value tokens from *Figma* inside one object.
/// If a color token exists with its value depending to the color scheme, it must be packed in such ``MultipleColorSemanticTokens`
///
/// ```swift
///         // Assuming in Figma with have a color semantic token colorBgPrimary,
///         // two semantic color tokens will be defined in Figma and generated by tokenator.
///         // They can be declared in protocol ColorSemanticTokens,
///         // and defined automaticaly in OUDSTheme+ColorSemanticTokens extension
///         var colorBgPrimaryLight: ColorSemanticToken { ColorRawTokens.colorFunctionalWhite }
///         var colorBgPrimaryDark: ColorSemanticToken { ColorRawTokens.colorFunctionalDarkGray880 }
///
///         // Then the develoment team declares an "higher" level color semantic token for colorBgPrimary
///         // inside ColorMultipleSemanticTokens protocol,
///         // and defined inside OUDSTheme+ColorMultipleSemanticToken extension
///         var colorBgPrimary: MultipleColorSemanticTokens { MultipleColorSemanticTokens(light: colorBgPrimaryLight, dark: colorBgPrimaryDark) }
///
///         // If the same color is used whatever the color scheme is
///         var colorBgPrimary: MultipleColorSemanticTokens { MultipleColorSemanticTokens(colorBgPrimaryLight) }
///
///         // The theme exposes both generated color semantic tokens and "crafted" higher level color semantic tokens.
///         // It is recommended to use the higher level version as it is less error-prone.
/// ```
///
///
/// ```swift
///      @Environment(\.theme) var theme
///      @Environment(\.colorScheme) var colorScheme
///
///     // Given you want to apply the color token "colorSurfaceBrandPrimary"
///     var body: some View {
///         // Apply the token of color for the view without managing yourself the color scheme
///         SomeView()
///             .oudsBackground(theme.colors.colorSurfaceBrandPrimary)
///
///         // Or also oudsForegroundtyle(), oudsForegroundColor(), oudsAccentColor(), ...
///     }
/// ```
///
/// ```swift
///     // Or get the token depending to the color scheme and do whatever you want with
///     theme.colors.colorSurfaceBrandPrimary.color(for: colorScheme)
/// ```
///
/// - Since: 0.8.0
public final class MultipleColorSemanticTokens: NSObject, Sendable {

    /// For **light** mode scheme
    public let light: ColorSemanticToken

    /// For **dark** mode scheme
    public let dark: ColorSemanticToken

    /// Initializes a new color multiple semantic token with the same value for light and dark modes
    /// - Parameter value: The `ColorSemanticToken` to apply wether the device is in *light* and *dark* mode
    public init(_ value: ColorSemanticToken) {
        light = value
        dark = value
    }

    /// Initializes a new color multiple semantic token with two values
    /// - Parameters:
    ///    - light: The `ColorSemanticToken` to apply if device in *light* mode
    ///    - dark: The `ColorSemanticToken` to apply if device in *dark* mode
    public init(light: ColorSemanticToken, dark: ColorSemanticToken) {
        self.light = light
        self.dark = dark
    }

    deinit {}

    /// Returns `true` if `self` and `object` has the same `light` and `dark` values and with `object`
    /// as a `MultipleColorRawToken`. Otherwise returns `false`.
    /// `isEqual` override is preferred for `NSObject`.
    override public func isEqual(_ object: Any?) -> Bool {
        guard let other = object as? MultipleColorSemanticTokens else { return false }
        return light == other.light && dark == other.dark
    }

    /// Returns the right color according to the `colorScheme`.
    /// - Parameter colorScheme: The color scheme in use to define the value to use
    /// - Returns: The `SwiftUI.Color` value to use
    public func color(for colorScheme: ColorScheme) -> Color {
        (colorScheme == .light ? light : dark).color
    }
}

// MARK: - Color WCAG 2.1

extension OUDSWCAG21Ratio {

    /// Flag to rise so as to display in logs some warnings if there are troubles
    /// with contrast ratios between colors. Default set to *false*.
    /// Consider rising this falge in DBUG mode.
    ///
    /// ```swift
    /// #if DEBUG
    ///     OUDSWCAG21Ratios.oudsDebugWCAG21Colors = true
    /// #else
    ///     OUDSWCAG21Ratios.oudsDebugWCAG21Colors = false
    /// #endif
    /// ```
    public nonisolated(unsafe) static var oudsDebugWCAG21Colors: Bool = false

    /// Lists the type of elements under tests for constrat ratio check.
    /// Textual elements should have higher contrasts than non-textual ones.
    public enum Target {
        /// Contrast ratio must be computed for textual components (i.e. texts)
        case textual
        /// Contrast ratio must be computed for non-textual components (i.e. images, indicators, chevrons, ...)
        case nonTextual
    }

    /// The type of WCAG 2.1 requirements to consider
    public enum Criteria {
        /// Consider 4.5:1 for textual and 3:1 for non-textual
        case AA
        /// Consider 7:1 for textual and 4.5:1 for non-textual
        case AAA
    }

    /// Checks the contrast ratio between two tokens of color (`MultipleColorSemanticTokens`) by comparing their *light*
    /// and *dark* values.
    /// **Checks are done if end only if the `OUDSWCAG21Ratios.oudsDebugWCAG21Colors` flag is set to true.**
    /// Otherwise nothing is done.
    /// If some ratios are not reached, displays a warning in logs.
    ///
    /// ```swift
    /// // Assuming you use a color from a theme
    /// @Environment(\.theme) var theme
    /// // Assuming a component is used on a colored surface, get the surface color
    /// @Environment(\.oudsSurfaceColor) var surfaceColor
    ///
    /// // Supposing tou want to apply "someColor" on a component on the colored surface
    /// let colorToApply = theme.colors.someColor
    ///
    /// // If you want to check for textual component
    /// OUDSWCAG21Ratios.debugContrastRatio(colorToApply, surfaceColor)
    ///
    /// // If you want to check for non-textual component (i.e. images, chevrons, indicators, ...)
    /// OUDSWCAG21Ratios.debugContrastRatio(colorToApply, surfaceColor, .nonTextual)
    ///
    /// // If you want to check the AAA requirements instead of AA (by default)
    /// OUDSWCAG21Ratios.debugContrastRatio(colorToApply, surfaceColor, .AAA)
    /// ```
    ///
    /// - Parameters:
    ///    - lhs: One color with light and dark values to compare with `rhs`
    ///    - rhs: One color with light and dark values to compare with `lhs`
    ///    - target: Type of check to do (default set to `.textual`)
    ///    - criteria: Requirement to consider (default set to `.AA`)
    ///    - source: Default set to `#file` to log the calling file to ease debugging
    /// - Returns Bool: `true` if light an dark colors pass tests, false otherwise or if flag not set
    @discardableResult
    public static func debugContrastRatio(_ lhs: MultipleColorSemanticTokens,
                                          _ rhs: MultipleColorSemanticTokens,
                                          _ target: OUDSWCAG21Ratio.Target = .textual,
                                          _ criteria: OUDSWCAG21Ratio.Criteria = .AA,
                                          _ source: String = #file) -> Bool
    {
        guard oudsDebugWCAG21Colors else {
            return false
        }
        let lightPass = Self.debugContrastRatio(for: "light", lhs.light, rhs.light, target, criteria, source)
        let darkPass = Self.debugContrastRatio(for: "dark", lhs.dark, rhs.dark, target, criteria, source)
        return lightPass && darkPass
    }

    private static func debugContrastRatio(for scheme: String,
                                           _ lhs: String,
                                           _ rhs: String,
                                           _ target: OUDSWCAG21Ratio.Target,
                                           _ criteria: OUDSWCAG21Ratio.Criteria,
                                           _ source: String) -> Bool
    {
        guard let ratio = OUDSWCAG21Ratio.contrastRatios(lhs, rhs) else {
            return false
        }
        switch criteria {
        case .AA where target == .textual:
            let (textualPass, _) = ratio.requirementsAA
            if !textualPass {
                OL.warning("ðŸ‘® In \(source) the \(scheme) color '\(lhs)' on surface '\(rhs)' does not match contrast ratio for text 4.5:1 (WCAG 2.1 AA) (ratio \(ratio.ratio))")
            }
            return textualPass
        case .AA where target == .nonTextual:
            let (_, nonTextualPass) = ratio.requirementsAA
            if !nonTextualPass {
                OL.warning("ðŸ‘® In \(source) the \(scheme) color '\(lhs)' on surface '\(rhs)' does not match contrast ratio for non-text 3:1 (WCAG 2.1 AA) (ratio \(ratio.ratio))")
            }
            return nonTextualPass
        case .AAA where target == .textual:
            let (textualPass, _) = ratio.requirementsAAA
            if !textualPass {
                OL.warning("ðŸ‘® In \(source) the \(scheme) color '\(lhs)' on surface '\(rhs)' does not match contrast ratio for text 7:1 (WCAG 2.1 AAA) (ratio \(ratio.ratio))")
            }
            return textualPass
        case .AAA where target == .nonTextual:
            let (_, nonTextualPass) = ratio.requirementsAAA
            if !nonTextualPass {
                OL.warning("ðŸ‘® In \(source) the \(scheme) color '\(lhs)' on surface '\(rhs)' does not match contrast ratio for nontext 4.5:1 (WCAG 2.1 AAA) (ratio \(ratio.ratio))")
            }
            return nonTextualPass
        default:
            OL.warning("ðŸ‘® Contrast check requirements not managed!")
            return false
        }
    }
}
