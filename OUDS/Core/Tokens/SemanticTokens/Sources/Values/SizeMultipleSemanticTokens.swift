//
// Software Name: OUDS iOS
// SPDX-FileCopyrightText: Copyright (c) Orange SA
// SPDX-License-Identifier: MIT
// 
// This software is distributed under the MIT license,
// the text of which is available at https://opensource.org/license/MIT/
// or see the "LICENSE" file for more details.
// 
// Authors: See CONTRIBUTORS.txt
// Software description: A SwiftUI components library with code examples for Orange Unified Design System 
//

// [File not generated by the tokenator]
// WARNING: Not synchronized anymore with the Figjam / Figma by developers team
// Create an issue for update https://github.com/Orange-OpenSource/ouds-ios/issues/new?template=token_update.yml

// swiftlint:disable missing_docs
// swiftlint:disable line_length

/// This is a group of semantic tokens for **size** but using ``MultipleSizeSemanticTokens``
///
/// In fact the ``MultipleSizeSemanticTokens`` class will help users (i.e. developers) to handle one semantic token for size containing values for compact and regular viewports / size classes.
/// Because *Figma* is not able to manage pair of values for one token, and its produced JSON does not reflect this mecanism, the *tokenator* cannot provide such ``MultipleSizeSemanticTokens``.
/// A major part the "real" size semantic tokens are declared in ``SizeSemanticTokens`` protocol and defined inside `OUDSTheme` (to be overridable then by subthemes), and othershere.
/// These tokens are updated by the *tokenator*.
/// Then they are gathered and wrapped so as to be used easily thanks to this ``MultipleSizeSemanticTokens`` which must be updated manually.
///
/// In few words:
/// ```swift
///         // Some sizing raw tokens, defined by the tokenator (in DimensionRawTokens+Values.swift)
///         public static let dimension550: DimensionRawToken = 44
///         public static let dimension650: DimensionRawToken = 52
///
///         // The sizing semantic tokens using them,
///         // declared (in SizeSemanticTokens.swift) and defined (in OUDSTheme+SizeSemanticTokens.swift) by the tokenator
///         var sizeIconWithHeadingXlargeSizeShortMobile: SizeSemanticToken { DimensionRawTokens.dimension550 }
///         var sizeIconWithHeadingXlargeSizeShortTablet: SizeSemanticToken { DimensionRawTokens.dimension650 }
///
///         // The 'higher level' size semantic tokens wrapping them and exposed to users,
///         // declared (in SizeMultipleSemanticTokens.swift) and defined (in OUDSTheme+SizeMultipleSemanticTokens.swift) manualy
///         var sizeIconWithHeadingXlargeSizeShort: MultipleSizeSemanticTokens {
///             MultipleSizeSemanticTokens(compact: sizeIconWithHeadingXlargeSizeShortMobile, regular: sizeIconWithHeadingXlargeSizeShortTablet)
///         }
///
///         // Thus users can in their components use sizeIconWithHeadingXlargeSizeShort as defined in their design system
///         // (even if they are still able to use 'lower level' semantic tokens but it is more error-prone)
/// ```
/// 
public protocol SizeMultipleSemanticTokens {

    // MARK: - Semantic token - Sizing - Icon with typography

    var sizeIconWithHeadingXlargeSizeShort: MultipleSizeSemanticTokens { get }
    var sizeIconWithHeadingXlargeSizeMedium: MultipleSizeSemanticTokens { get }
    var sizeIconWithHeadingXlargeSizeTall: MultipleSizeSemanticTokens { get }

    var sizeIconWithHeadingLargeSizeShort: MultipleSizeSemanticTokens { get }
    var sizeIconWithHeadingLargeSizeMedium: MultipleSizeSemanticTokens { get }
    var sizeIconWithHeadingLargeSizeTall: MultipleSizeSemanticTokens { get }

    var sizeIconWithHeadingMediumSizeShort: MultipleSizeSemanticTokens { get }
    var sizeIconWithHeadingMediumSizeMedium: MultipleSizeSemanticTokens { get }
    var sizeIconWithHeadingMediumSizeTall: MultipleSizeSemanticTokens { get }

    var sizeIconWithHeadingSmallSizeShort: MultipleSizeSemanticTokens { get }
    var sizeIconWithHeadingSmallSizeMedium: MultipleSizeSemanticTokens { get }
    var sizeIconWithHeadingSmallSizeTall: MultipleSizeSemanticTokens { get }

    var sizeIconWithBodyLargeSizeShort: MultipleSizeSemanticTokens { get }
    var sizeIconWithBodyLargeSizeMedium: MultipleSizeSemanticTokens { get }
    var sizeIconWithBodyLargeSizeTall: MultipleSizeSemanticTokens { get }

    var sizeIconWithBodyMediumSizeShort: MultipleSizeSemanticTokens { get }
    var sizeIconWithBodyMediumSizeMedium: MultipleSizeSemanticTokens { get }
    var sizeIconWithBodyMediumSizeTall: MultipleSizeSemanticTokens { get }

    var sizeIconWithBodySmallSizeShort: MultipleSizeSemanticTokens { get }
    var sizeIconWithBodySmallSizeMedium: MultipleSizeSemanticTokens { get }
    var sizeIconWithBodySmallSizeTall: MultipleSizeSemanticTokens { get }

    // MARK: - Semantic token - Sizing - Max width typography

    var sizeMaxWidthTypeDisplayLarge: MultipleSizeSemanticTokens { get }
    var sizeMaxWidthTypeDisplayMedium: MultipleSizeSemanticTokens { get }
    var sizeMaxWidthTypeDisplaySmall: MultipleSizeSemanticTokens { get }

    var sizeMaxWidthTypeHeadingXlarge: MultipleSizeSemanticTokens { get }
    var sizeMaxWidthTypeHeadingLarge: MultipleSizeSemanticTokens { get }
    var sizeMaxWidthTypeHeadingMedium: MultipleSizeSemanticTokens { get }
    var sizeMaxWidthTypeHeadingSmall: MultipleSizeSemanticTokens { get }

    var sizeMaxWidthTypeBodyLarge: MultipleSizeSemanticTokens { get }
    var sizeMaxWidthTypeBodyMedium: MultipleSizeSemanticTokens { get }
    var sizeMaxWidthTypeBodySmall: MultipleSizeSemanticTokens { get }
}

// swiftlint:enable missing_docs
// swiftlint:enable line_length
