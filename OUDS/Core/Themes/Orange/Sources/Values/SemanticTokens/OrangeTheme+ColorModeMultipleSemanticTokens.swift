//
// Software Name: OUDS iOS
// SPDX-FileCopyrightText: Copyright (c) Orange SA
// SPDX-License-Identifier: MIT
//
// This software is distributed under the MIT license,
// the text of which is available at https://opensource.org/license/MIT/
// or see the "LICENSE" file for more details.
//
// Authors: See CONTRIBUTORS.txt
// Software description: A SwiftUI components library with code examples for Orange Unified Design System
//

import Foundation
import OUDSFoundations
import OUDSTokensRaw
import OUDSTokensSemantic
import SwiftUI

// [File not generated by the tokenator]
// Create an issue for update https://github.com/Orange-OpenSource/ouds-ios/issues/new?template=token_update.yml

// swiftlint:disable line_length

/// Defines provider objects for `ColorModeSemanticTokens` so as to pack them as light and dark mode colors.
/// These values can be overriden inside `OrangeThemeColorModeSemanticTokensProvider` subclasses (in extensions or not, in the same module or not) thanks to the `@objc open` combination.
extension OrangeThemeColorModeSemanticTokensProvider: ColorModeMultipleSemanticTokens {

    // MARK: - Multiple tokens

    @objc open var onBgPrimary: MultipleColorModeSemanticTokens { MultipleColorModeSemanticTokens("onBgPrimary", light: onBgPrimaryLight, dark: onBgPrimaryDark) }

    @objc open var onBgSecondary: MultipleColorModeSemanticTokens { MultipleColorModeSemanticTokens("onBgSecondary", light: onBgSecondaryLight, dark: onBgSecondaryDark) }

    @objc open var onBgTertiary: MultipleColorModeSemanticTokens { MultipleColorModeSemanticTokens("onBgTertiary", light: onBgTertiaryLight, dark: onBgTertiaryDark) }

    @objc open var onBrandPrimary: MultipleColorModeSemanticTokens { MultipleColorModeSemanticTokens("onBrandPrimary", light: onBrandPrimaryLight, dark: onBrandPrimaryDark) }

    @objc open var onBrandSecondary: MultipleColorModeSemanticTokens { MultipleColorModeSemanticTokens("onBrandSecondary", light: onBrandSecondaryLight, dark: onBrandSecondaryDark) }

    @objc open var onBrandTertiary: MultipleColorModeSemanticTokens { MultipleColorModeSemanticTokens("onBrandTertiary", light: onBrandTertiaryLight, dark: onBrandTertiaryDark) }

    @objc open var onOverlayModal: MultipleColorModeSemanticTokens { MultipleColorModeSemanticTokens("onModalOverlay", light: onOverlayModalLight, dark: onOverlayModalDark) }

    @objc open var onOverlayDropdown: MultipleColorModeSemanticTokens { MultipleColorModeSemanticTokens("onOverlayDropdown", light: onOverlayDropdownLight, dark: onOverlayDropdownDark) }

    @objc open var onOverlayTooltip: MultipleColorModeSemanticTokens { MultipleColorModeSemanticTokens("onOverlayTooltip", light: onOverlayTooltipLight, dark: onOverlayTooltipDark) }

    @objc open var onStatusAccentEmphasized: MultipleColorModeSemanticTokens { MultipleColorModeSemanticTokens("onStatusAccentEmphasized", light: onStatusAccentEmphasizedLight, dark: onStatusAccentEmphasizedDark) }

    @objc open var onStatusAccentMuted: MultipleColorModeSemanticTokens { MultipleColorModeSemanticTokens("onStatusAccentMuted", light: onStatusAccentMutedLight, dark: onStatusAccentMutedDark) }

    @objc open var onStatusInfoEmphasized: MultipleColorModeSemanticTokens { MultipleColorModeSemanticTokens("onStatusInfoEmphasized", light: onStatusInfoEmphasizedLight, dark: onStatusInfoEmphasizedDark) }

    @objc open var onStatusInfoMuted: MultipleColorModeSemanticTokens { MultipleColorModeSemanticTokens("onStatusInfoMuted", light: onStatusInfoMutedLight, dark: onStatusInfoMutedDark) }

    @objc open var onStatusNegativeEmphasized: MultipleColorModeSemanticTokens { MultipleColorModeSemanticTokens("onStatusNegativeEmphasized", light: onStatusNegativeEmphasizedLight, dark: onStatusNegativeEmphasizedDark) }

    @objc open var onStatusNegativeMuted: MultipleColorModeSemanticTokens { MultipleColorModeSemanticTokens("onStatusNegativeMuted", light: onStatusNegativeMutedLight, dark: onStatusNegativeMutedDark) }

    @objc open var onStatusPositiveEmphasized: MultipleColorModeSemanticTokens { MultipleColorModeSemanticTokens("onStatusPositiveEmphasized", light: onStatusPositiveEmphasizedLight, dark: onStatusPositiveEmphasizedDark) }

    @objc open var onStatusPositiveMuted: MultipleColorModeSemanticTokens { MultipleColorModeSemanticTokens("onStatusPositiveMuted", light: onStatusPositiveMutedLight, dark: onStatusPositiveMutedDark) }

    @objc open var onStatusWarningEmphasized: MultipleColorModeSemanticTokens { MultipleColorModeSemanticTokens("onStatusWarningEmphasized", light: onStatusWarningEmphasizedLight, dark: onStatusWarningEmphasizedDark) }

    @objc open var onStatusWarningMuted: MultipleColorModeSemanticTokens { MultipleColorModeSemanticTokens("onStatusWarningMuted", light: onStatusWarningMutedLight, dark: onStatusWarningMutedDark) }

    @objc open var navigationBar: MultipleColorModeSemanticTokens { MultipleColorModeSemanticTokens("navigationBarDark", light: navigationBarLight, dark: navigationBarDark) }

    // MARK: - Additional rules

    /// Depending to the given `mode`, should return the SwfitUI `ColorScheme` to consider.
    /// For Orange theme, the rules are:
    /// - if light version is dark mode and dark version is light mode, reverse the color scheme
    /// - if light and dark versions are light mode, return light color scheme
    /// - if light and dark versions are dark mode, return dark color scheme
    /// - otherwise return current color scheme
    ///
    /// - Parameters:
    ///    - mode: The color mode token to test
    ///    - current: The current color scheme
    /// - Returns: The color scheme to consider depending to the theme rules
    public func useColorScheme(for mode: MultipleColorModeSemanticTokens,
                               _ current: ColorScheme) -> ColorScheme
    {

        let lightColorScheme = ColorModeRawTokens.colorScheme(for: mode.light)
        let darkColorScheme = ColorModeRawTokens.colorScheme(for: mode.dark)

        // Reverse the color scheme to apply
        if lightColorScheme == .dark, darkColorScheme == .light {
            return current == .light ? .dark : .light
        }

        // Force light
        if lightColorScheme == .light, darkColorScheme == .light {
            return .light
        }

        // Force dark
        if lightColorScheme == .dark, darkColorScheme == .dark {
            return .dark
        }

        // Otherwise use device configuration
        return current
    }

    /// Depending to the given `mode`, should return a flag saying if monochrome mode must be considered.
    /// For Orange theme, the rule is :
    /// - if both light and dark versions are monochrome, returns true, otherwise false
    ///
    /// - Parameter mode: The color mode token to test
    /// - Returns: The flag for monochrome mode depending to the theme rules
    public func isMonochrome(mode: MultipleColorModeSemanticTokens) -> Bool {
        let lightIsMonochrome = ColorModeRawTokens.isMonochrome(mode: mode.light)
        let darkIsMonochrome = ColorModeRawTokens.isMonochrome(mode: mode.dark)
        return lightIsMonochrome == true && darkIsMonochrome == true
    }

    // swiftlint:disable cyclomatic_complexity
    /// Returns the colors semantic token depending to the given color mode.
    /// If the given color mode has undefined value, or is not managed, triggers a fatal error as not expected situation.
    ///
    /// - Parameter mode: The color mpde token to use
    /// - Returns: The colors to apply
    public func toColor(from mode: MultipleColorModeSemanticTokens) -> MultipleColorSemanticTokens {
        guard !mode.hasUndefinedValue() else {
            OL.fatal("Trying to use color mode '\(mode.name)' with undefined value / forbidden color value for Orange Theme")
        }
        // List here all cases where light and dark mode values are NOT undefined
        if mode.isEqual(onBgPrimary) { return colors.bgPrimary }
        if mode.isEqual(onBgSecondary) { return colors.bgSecondary }
        if mode.isEqual(onBgTertiary) { return colors.bgTertiary }
        if mode.isEqual(onBrandPrimary) { return colors.surfaceBrandPrimary }
        if mode.isEqual(onBrandSecondary) { return colors.surfaceBrandSecondary }
        if mode.isEqual(onBrandTertiary) { return colors.surfaceBrandTertiary }
        if mode.isEqual(onOverlayModal) { return colors.overlayModal }
        if mode.isEqual(onStatusAccentEmphasized) { return colors.surfaceStatusAccentEmphasized }
        if mode.isEqual(onStatusAccentMuted) { return colors.surfaceStatusAccentMuted }
        if mode.isEqual(onStatusInfoEmphasized) { return colors.surfaceStatusInfoEmphasized }
        if mode.isEqual(onStatusInfoMuted) { return colors.surfaceStatusInfoMuted }
        if mode.isEqual(onStatusNegativeEmphasized) { return colors.surfaceStatusNegativeEmphasized }
        if mode.isEqual(onStatusNegativeMuted) { return colors.surfaceStatusNegativeMuted }
        if mode.isEqual(onStatusPositiveEmphasized) { return colors.surfaceStatusPositiveEmphasized }
        if mode.isEqual(onStatusPositiveMuted) { return colors.surfaceStatusPositiveMuted }
        if mode.isEqual(onStatusWarningEmphasized) { return colors.surfaceStatusWarningEmphasized }
        if mode.isEqual(onStatusWarningMuted) { return colors.surfaceStatusWarningMuted }
        if mode.isEqual(onOverlayDropdown) { return colors.overlayDropdown }
        if mode.isEqual(onOverlayTooltip) { return colors.overlayModal } // FIXME: Not sure of this value
        if mode.isEqual(navigationBar) { return colors.overlayModal } // FIXME: Not sure of this value
        OL.fatal("The color mode '\(mode.name)' for Orange Theme is not managed and must be.")
    }
    // swiftlint:enable cyclomatic_complexity
}

// swiftlint:enable line_length
