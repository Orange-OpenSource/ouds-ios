//
// Software Name: OUDS iOS
// SPDX-FileCopyrightText: Copyright (c) Orange SA
// SPDX-License-Identifier: MIT
//
// This software is distributed under the MIT license,
// the text of which is available at https://opensource.org/license/MIT/
// or see the "LICENSE" file for more details.
//
// Authors: See CONTRIBUTORS.txt
// Software description: A SwiftUI components library with code examples for Orange Unified Design System
//

import Foundation
import OUDSFoundations
import OUDSTokensRaw
import OUDSTokensSemantic
import SwiftUI

// [File not generated by the tokenator]
// Create an issue for update https://github.com/Orange-OpenSource/ouds-ios/issues/new?template=token_update.yml

// swiftlint:disable line_length

/// Defines provider objects for `ColorModeSemanticTokens` so as to pack them as light and dark mode colors.
/// These values can be overriden inside `OrangeThemeColorModeSemanticTokensProvider` subclasses (in extensions or not, in the same module or not) thanks to the `@objc open` combination.
extension OrangeThemeColorModeSemanticTokensProvider: ColorModeMultipleSemanticTokens {

    // MARK: - Multiple tokens

    @objc open var modeOnBgPrimary: MultipleColorModeSemanticTokens { MultipleColorModeSemanticTokens("modeOnBgPrimary", light: modeOnBgPrimaryLight, dark: modeOnBgPrimaryDark) }

    @objc open var modeOnBgSecondary: MultipleColorModeSemanticTokens { MultipleColorModeSemanticTokens("modeOnBgSecondary", light: modeOnBgSecondaryLight, dark: modeOnBgSecondaryDark) }

    @objc open var modeOnBgTertiary: MultipleColorModeSemanticTokens { MultipleColorModeSemanticTokens("modeOnBgTertiary", light: modeOnBgTertiaryLight, dark: modeOnBgTertiaryDark) }

    @objc open var modeOnBgEmphasized: MultipleColorModeSemanticTokens { MultipleColorModeSemanticTokens("modeOnBgEmphasized", light: modeOnBgEmphasizedLight, dark: modeOnBgEmphasizedDark) }

    @objc open var modeOnBrandPrimary: MultipleColorModeSemanticTokens { MultipleColorModeSemanticTokens("modeOnBrandPrimary", light: modeOnBrandPrimaryLight, dark: modeOnBrandPrimaryDark) }

    @objc open var modeOnBrandSecondary: MultipleColorModeSemanticTokens { MultipleColorModeSemanticTokens("modeOnBrandSecondary", light: modeOnBrandSecondaryLight, dark: modeOnBrandSecondaryDark) }

    @objc open var modeOnBrandTertiary: MultipleColorModeSemanticTokens { MultipleColorModeSemanticTokens("modeOnBrandTertiary", light: modeOnBrandTertiaryLight, dark: modeOnBrandTertiaryDark) }

    @objc open var modeOnStatusAccentEmphasized: MultipleColorModeSemanticTokens { MultipleColorModeSemanticTokens("modeOnStatusAccentEmphasized", light: modeOnStatusAccentEmphasizedLight, dark: modeOnStatusAccentEmphasizedDark) }

    @objc open var modeOnStatusAccentMuted: MultipleColorModeSemanticTokens { MultipleColorModeSemanticTokens("modeOnStatusAccentMuted", light: modeOnStatusAccentMutedLight, dark: modeOnStatusAccentMutedDark) }

    @objc open var modeOnStatusInfoEmphasized: MultipleColorModeSemanticTokens { MultipleColorModeSemanticTokens("modeOnStatusInfoEmphasized", light: modeOnStatusInfoEmphasizedLight, dark: modeOnStatusInfoEmphasizedDark) }

    @objc open var modeOnStatusInfoMuted: MultipleColorModeSemanticTokens { MultipleColorModeSemanticTokens("modeOnStatusInfoMuted", light: modeOnStatusInfoMutedLight, dark: modeOnStatusInfoMutedDark) }

    @objc open var modeOnStatusNegativeEmphasized: MultipleColorModeSemanticTokens { MultipleColorModeSemanticTokens("modeOnStatusNegativeEmphasized", light: modeOnStatusNegativeEmphasizedLight, dark: modeOnStatusNegativeEmphasizedDark) }

    @objc open var modeOnStatusNegativeMuted: MultipleColorModeSemanticTokens { MultipleColorModeSemanticTokens("modeOnStatusNegativeMuted", light: modeOnStatusNegativeMutedLight, dark: modeOnStatusNegativeMutedDark) }

    @objc open var modeOnStatusNeutralEmphasized: MultipleColorModeSemanticTokens { MultipleColorModeSemanticTokens("modeOnStatusNeutralEmphasized", light: modeOnStatusNeutralEmphasizedLight, dark: modeOnStatusNeutralEmphasizedDark) }

    @objc open var modeOnStatusNeutralMuted: MultipleColorModeSemanticTokens { MultipleColorModeSemanticTokens("modeOnStatusNeutralMuted", light: modeOnStatusNeutralMutedLight, dark: modeOnStatusNeutralMutedDark) }

    @objc open var modeOnStatusPositiveEmphasized: MultipleColorModeSemanticTokens { MultipleColorModeSemanticTokens("modeOnStatusPositiveEmphasized", light: modeOnStatusPositiveEmphasizedLight, dark: modeOnStatusPositiveEmphasizedDark) }

    @objc open var modeOnStatusPositiveMuted: MultipleColorModeSemanticTokens { MultipleColorModeSemanticTokens("modeOnStatusPositiveMuted", light: modeOnStatusPositiveMutedLight, dark: modeOnStatusPositiveMutedDark) }

    @objc open var modeOnStatusWarningEmphasized: MultipleColorModeSemanticTokens { MultipleColorModeSemanticTokens("modeOnStatusWarningEmphasized", light: modeOnStatusWarningEmphasizedLight, dark: modeOnStatusWarningEmphasizedDark) }

    @objc open var modeOnStatusWarningMuted: MultipleColorModeSemanticTokens { MultipleColorModeSemanticTokens("modeOnStatusWarningMuted", light: modeOnStatusWarningMutedLight, dark: modeOnStatusWarningMutedDark) }

    @objc open var modeOnOverlayDefault: MultipleColorModeSemanticTokens { MultipleColorModeSemanticTokens("modeOnOverlayDefault", light: modeOnOverlayDefaultLight, dark: modeOnOverlayDefaultDark) }

    @objc open var modeOnOverlayEmphasized: MultipleColorModeSemanticTokens { MultipleColorModeSemanticTokens("modeOnOverlayEmphasized", light: modeOnOverlayEmphasizedLight, dark: modeOnOverlayEmphasizedDark) }

    @objc open var modeOnModalOverlay: MultipleColorModeSemanticTokens { MultipleColorModeSemanticTokens("modeOnModalOverlay", light: modeOnOverlayModalLight, dark: modeOnOverlayModalDark) }

    // MARK: - Additional rules

    /// Depending to the given `mode`, should return the SwfitUI `ColorScheme` to consider.
    /// For Orange theme, the rules are:
    /// - if light version is dark mode and dark version is light mode, reverse the color scheme
    /// - if light and dark versions are light mode, return light color scheme
    /// - if light and dark versions are dark mode, return dark color scheme
    /// - otherwise return current color scheme
    ///
    /// - Parameters:
    ///    - mode: The color mode token to test
    ///    - current: The current color scheme
    /// - Returns: The color scheme to consider depending to the theme rules
    public func useColorScheme(for mode: MultipleColorModeSemanticTokens,
                               _ current: ColorScheme) -> ColorScheme
    {

        let lightColorScheme = ColorModeRawTokens.colorScheme(for: mode.light)
        let darkColorScheme = ColorModeRawTokens.colorScheme(for: mode.dark)

        // Reverse the color scheme to apply
        if lightColorScheme == .dark, darkColorScheme == .light {
            return current == .light ? .dark : .light
        }

        // Force light
        if lightColorScheme == .light, darkColorScheme == .light {
            return .light
        }

        // Force dark
        if lightColorScheme == .dark, darkColorScheme == .dark {
            return .dark
        }

        // Otherwise use device configuration
        return current
    }

    /// Depending to the given `mode`, should return a flag saying if monochrome mode must be considered.
    /// For Orange theme, the rule is :
    /// - if both light and dark versions are monochrome, returns true, otherwise false
    ///
    /// - Parameter mode: The color mode token to test
    /// - Returns: The flag for monochrome mode depending to the theme rules
    public func isMonochrome(mode: MultipleColorModeSemanticTokens) -> Bool {
        let lightIsMonochrome = ColorModeRawTokens.isMonochrome(mode: mode.light)
        let darkIsMonochrome = ColorModeRawTokens.isMonochrome(mode: mode.dark)
        return lightIsMonochrome == true && darkIsMonochrome == true
    }

    // swiftlint:disable cyclomatic_complexity
    /// Returns the colors semantic token depending to the given color mode.
    /// If the given color mode has undefined value, or is not managed, triggers a fatal error as not expected situation.
    ///
    /// - Parameter mode: The color mpde token to use
    /// - Returns: The colors to apply
    public func toColor(from mode: MultipleColorModeSemanticTokens) -> MultipleColorSemanticTokens {
        guard !mode.hasUndefinedValue() else {
            OL.fatal("Trying to use color mode '\(mode.name)' with undefined value / forbidden color value for Orange Theme")
        }
        // List here all cases where light and dark mode values are NOT undefined
        if mode.isEqual(modeOnBgPrimary) { return colors.colorBgPrimary }
        if mode.isEqual(modeOnBgSecondary) { return colors.colorBgSecondary }
        if mode.isEqual(modeOnBgTertiary) { return colors.colorBgTertiary }
        if mode.isEqual(modeOnBgEmphasized) { return colors.colorBgEmphasized }
        if mode.isEqual(modeOnBrandPrimary) { return colors.colorContentBrandPrimary }
        // modeOnBrandSecondary and modeOnBrandTertiary have undefined values for this theme
        if mode.isEqual(modeOnStatusNeutralMuted) { return colors.colorSurfaceStatusNeutralMuted }
        if mode.isEqual(modeOnStatusNeutralEmphasized) { return colors.colorSurfaceStatusNeutralEmphasized }
        if mode.isEqual(modeOnStatusPositiveMuted) { return colors.colorSurfaceStatusPositiveMuted }
        if mode.isEqual(modeOnStatusPositiveEmphasized) { return colors.colorSurfaceStatusPositiveEmphasized }
        if mode.isEqual(modeOnStatusInfoMuted) { return colors.colorSurfaceStatusInfoMuted }
        if mode.isEqual(modeOnStatusInfoEmphasized) { return colors.colorSurfaceStatusInfoEmphasized }
        if mode.isEqual(modeOnStatusWarningMuted) { return colors.colorSurfaceStatusWarningMuted }
        if mode.isEqual(modeOnStatusWarningEmphasized) { return colors.colorSurfaceStatusWarningEmphasized }
        if mode.isEqual(modeOnStatusNegativeMuted) { return colors.colorSurfaceStatusNegativeMuted }
        if mode.isEqual(modeOnStatusNegativeEmphasized) { return colors.colorSurfaceStatusNegativeEmphasized }
        if mode.isEqual(modeOnStatusAccentMuted) { return colors.colorSurfaceStatusAccentMuted }
        if mode.isEqual(modeOnStatusAccentEmphasized) { return colors.colorSurfaceStatusAccentEmphasized }
        if mode.isEqual(modeOnOverlayDefault) { return colors.colorOverlayDefault }
        if mode.isEqual(modeOnOverlayEmphasized) { return colors.colorOverlayEmphasized }
        if mode.isEqual(modeOnModalOverlay) { return colors.colorOverlayModal }
        OL.fatal("The color mode '\(mode.name)' for Orange Theme is not managed and must be.")
    }
    // swiftlint:enable cyclomatic_complexity
}

// swiftlint:enable line_length
